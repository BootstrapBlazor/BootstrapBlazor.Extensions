<span class="mermaid" style="@Style" id="@Id">
	@if (Type != MermaidType.None)
	{
		@Type
		@if (Type == MermaidType.flowchart || Type == MermaidType.stateDiagram)
		{
			@(" " + Direction)
		}
		@if (!string.IsNullOrEmpty(MermaidTitle)&&
												(Type==MermaidType.gantt
												||Type==MermaidType.pie
												||Type==MermaidType.sequenceDiagram
												))
		{
			@("\ntitle " + MermaidTitle)
		}
	}
	@ChildContent
</span>


@code{
	[Parameter]
	public MermaidDirection? Direction { get; set; } = MermaidDirection.TD;
	[Inject]
	[NotNull]
	private IJSRuntime? JSRuntime { get; set; }
	private IJSObjectReference? Module { get; set; }
	[Parameter]
	public RenderFragment? ChildContent{ get; set; }
	[Parameter]
	public Func<string, Task>? OnError { get; set; }
	[Parameter]
	public string? Style { get; set; } = string.Empty;
	[Parameter]
	public Guid? Id { set; get; } = Guid.NewGuid(); 
	[Parameter]
	public MermaidType? Type { set; get; } = MermaidType.None;
	[Parameter]
	public string? MermaidTitle { set; get; } = string.Empty;

	public enum MermaidType{
		None,
		flowchart,
		sequenceDiagram,
		classDiagram,
		stateDiagram,
		erDiagram,
		journey,
		gantt,
		pie
	};

	public enum MermaidDirection{
		TD,
		TB,
		BT,
		LR,
		RL
	}

	protected override async Task OnInitializedAsync()
	{
		try
		{
			Module = await JSRuntime.InvokeAsync<IJSObjectReference>("import", "/js/mermaidHelper.js");
			await Module.InvokeVoidAsync("removeComment");
			await Module.InvokeVoidAsync("loadMermaidContent");

		}
		catch (Exception e)
		{
			if (OnError != null) await OnError.Invoke(e.Message);
		}
		StateHasChanged();
		await base.OnInitializedAsync();
	}

	public async Task<string> ExportBase64MermaidAsync(){
		return await Module!.InvokeAsync<string>("exportBase64Mermaid",this.Id);
	}
}
